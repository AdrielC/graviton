2025-11-06 — Comprehensive Migration Playbook
==============================================

High-Level Intent
-----------------
- Reconcile `main` (lean core, VitePress docs, minimal chunker) with the `docs-deploy` feature branch (rich ingest stack, Docusaurus site, extensive scripts) without destabilizing production quality.
- Capture every major concept—strong types, chunking, mime sniffing, ingest pipeline, storage substrates, docs tooling, and PG integration—so another agent can execute the migration with clarity and confidence.
- Maintain a continuous delivery posture: each phase should be mergeable on its own, with deterministic acceptance checks and documentation updates.

Repository Baseline Snapshot
----------------------------
### `main`
- Modules follow a flatter structure (`modules/graviton-core`, `graviton-streams`, etc.).
- Binary attributes rely on `Tracked[A]` fields plus `extra` map; no namespaced keys.
- Chunking limited to fixed-size rechunk via `ZPipeline.rechunk`.
- Docs served via VitePress (`docs/.vitepress`), content aligned with current APIs.
- Build tooling already on Scala 3.7.3; CI pipelines expect VitePress site and Scaladoc bundling.

### `docs-deploy`
- Restructured module tree with core APIs, ingest pipeline, chunkers, frames scaffolding, metrics, cache stores, and new tests.
- Docusaurus-based documentation under `docs/src` with React components, custom theme, and npm-managed assets.
- Scripts expanded (`build-docs.sh`, hardened `ensure-postgres.sh`, `pg-init-codegen.sh`).
- PG schemas regenerated, new generated sources, and additional tests.
- Introduces job agent notes, roadmaps, and extensive Markdown guides.

Strategic Objectives
--------------------
- **Types & Safety**: Reinstate opaque/refined domain types (Block, UploadChunk, sizes, indices) layered over `Tracked[A]` without breaking existing API surface.
- **Chunking & Scans**: Restore FastCDC, rolling hash, token-aware chunkers, chunker hints, FreeScan/FreeArrow systems, and future-proof descriptors for optimizers.
- **Streaming & Storage**: Adopt minimal-copy pipelines, temp-file pools, resource tracking, and plan for mmap/io_uring exploration.
- **Mime Detection**: Deliver a best-effort streaming mime sniffer with tunable heuristics and Tika fallback integration points.
- **Ingest & Manifests**: Provide FileIngestor + hashing + manifest assembly with manifest/model alignment.
- **Docs & Website**: Merge Docusaurus learnings into main while keeping VitePress as published output; introduce `mdoc` to share runnable snippets; clean stale agent metadata.
- **Postgres & Scripts**: Integrate hardened scripts, codegen updates, and tests with minimal friction for contributors and CI.

Branch & Integration Strategy
-----------------------------
- Create a new feature branch from `main` (e.g., `feature/migrate-docs-deploy`) to stage the work.
- Cherry-pick or selectively copy files from `origin/docs-deploy` per workstream; avoid wholesale merge to limit unrelated churn.
- After each phase, squash-merge into the feature branch, run baseline checks, and document outcomes in this log.
- Once all phases pass acceptance, open a PR from the feature branch to `main` with detailed release notes and docs updates.

Workstreams Overview
--------------------
1. **Domain Types & Ergonomics**
2. **Chunking & Scan Composition**
3. **Mime Sniffing & Content Hints**
4. **Ingest Pipeline & Hashing**
5. **Storage Substrates & Resource Management**
6. **Planner & Optimization**
7. **Database & Script Hardening**
8. **Documentation & Website**
9. **Quality Gates & Automation**

Phase Plan (Detailed)
---------------------

### Phase 0 — Baseline & Tooling Sync
- **Tasks**
  - Branch from `main`, confirm clean status (`git status --short`).
  - Run `TESTCONTAINERS=0 ./sbt scalafmtAll test` and `cd docs && npm ci && npm run docs:build` to ensure local environment ready.
  - Inventory `docs-deploy` commits: categorize into domain code, docs, scripts, infra.
  - Update this job log with findings and assignments.
- **Dependencies**: None.
- **Acceptance**: Baseline tests and docs build pass; migration backlog categorized.

### Phase 1 — Type Foundations & BinaryAttributes Integration
- **Tasks**
  - Reintroduce opaque/refined types (`Block`, `UploadChunk`, `BlockSize`, `BlockIndex`, `FileSize`, `ChunkSize`, `ChunkCount`).
  - Provide smart constructors returning `Either[String, *]` or `ZIO` (no throws) and extension methods for conversions.
  - Layer types onto existing API surfaces while keeping `Tracked[A]` fields (size, mime, digests) intact.
  - Add unit tests for bounds, conversions, and integration with `Tracked` semantics.
- **Dependencies**: Phase 0.
- **Acceptance**
  - Core compiles, tests covering constructors & attribute integration.
  - Scaladoc updated for new types; docs stub for type rationale.

### Phase 2 — Chunking Strategies & Selection Engine
- **Tasks**
  - Port FastCDC, rolling hash, token-aware chunking pipelines from `docs-deploy` with adjustments for new type wrappers.
  - Implement `Chunker.select(hints: ChunkerHints)` with heuristics (content length, mime, prior knowledge), and ensure defaults degrade gracefully.
  - Provide tests: shape, bounds, determinism, throughput sanity checks (benchmark harness optional but recommended).
  - Document strategy selection matrix and fallback behaviors.
- **Dependencies**: Phase 1 types (for block size enforcement).
- **Acceptance**
  - All chunking tests pass; integration tests demonstrate switching strategies.
  - Docs describe algorithms, heuristics, and configuration toggles.

### Phase 3 — Mime Sniffer (Pass 1) & Content Hints
- **Tasks**
  - Create `modules/graviton-sniff` (or similar) containing streaming mime detection.
  - Implement layered detection:
    1. Magic number table (common file types, sensitive to offsets).
    2. Header heuristics (MIME markers, structure hints).
    3. Optional Tika integration behind capability flag.
  - Provide streaming API returning `Option[Mime]` early when confident; fall back to unknown gracefully.
  - Write fixtures & regression tests for PDFs, ZIPs, media, text, fallback cases.
  - Wire `ChunkerHints` to incorporate sniffer results.
- **Dependencies**: Phase 2 (chunker hints).
- **Acceptance**
  - Sniffer achieves target precision/recall on fixtures.
  - Integration test demonstrates ingest pipeline receiving mime hints.
  - Docs include sniffing guide with limitations and performance notes.

### Phase 4 — Ingest Pipeline & Hashing Integration
- **Tasks**
  - Implement FileIngestor that:
    - Reads bytes as `ZStream`, selects chunker via hints, yields `Block`s with enforced bounds.
    - Pipes through hashing folds (single or multi-algo) and accumulates manifest spans.
    - Updates `BinaryAttributes` tracked fields (size, chunkCount, mime), recording provenance.
  - Ensure interoperability with existing storage API (BlockStore/BlobStore) and manifest models.
  - Provide E2E tests using in-memory store and filesystem backend.
  - Capture streaming metrics (duration, chunk count, bytes processed) for future instrumentation.
- **Dependencies**: Phases 1–3.
- **Acceptance**
  - E2E ingest tests pass for small and large files.
  - Attributes, manifest entries, digests validated in tests.
  - Docs include ingest walkthrough with diagrams and sample code (mdoc-backed).

### Phase 5 — Storage Substrates & Resource Tracking
- **Tasks**
  - Restore/implement DiskCacheStore, RocksCacheStore, InMemory variants as per `docs-deploy`, updated for new types.
  - Add temp-file pool with configurable capacity, per-upload allocation tracking via STM registry.
  - Provide direct buffer pool + semaphore to guard limited resources; integrate with ingest pipeline.
  - Evaluate memory-mapped read cache behind flag; document trade-offs.
  - Include metrics collection (current usage, pool occupancy, backpressure counts).
- **Dependencies**: Phase 4 (ingest) provides integration points.
- **Acceptance**
  - Stress/integration tests for concurrent uploads pass.
  - Resource usage metrics accessible; default config safe for modest hardware.
  - Docs include storage substrate guide and tuning checklist.

### Phase 6 — Planner, Free Composition & Optimization Layer
- **Tasks**
  - Port FreeScan/FreeArrow combinators, ensuring compatibility with existing FreeScanV2 in `main`; provide migration adapters.
  - Define `Descriptor[A]` typeclass capturing compile-time metadata (shape, resource needs, cost hints) and `RuntimeDescriptor` for dynamic info.
  - Implement small rule-based optimizer that maps descriptors + environment hints to policy decisions (chunker selection, hashing strategies, parallelism).
  - Provide property tests verifying optimizer invariants (idempotence, monotonic resource usage).
- **Dependencies**: Phases 1–5 for types, chunkers, ingest.
- **Acceptance**
  - New scans compile and coexist with legacy consumers.
  - Optimizer decisions logged and testable; docs describe descriptor model.

### Phase 7 — Documentation, mdoc Integration & Site Convergence
- **Tasks**
  - Introduce `docs/mdoc/` with shared code snippets; add sbt `mdoc` task to build.
  - Bridge mdoc output into VitePress (e.g., copy generated Markdown into `docs/`), ensuring developers run `sbt mdoc` before committing.
  - Port Docusaurus content selectively: convert major guides (types, chunking, ingest, storage, sniffing, planner) into VitePress structure; retire overlapping Markdown in root when replaced.
  - Update docs build pipeline to run `sbt mdoc` + `npm run docs:build`.
  - Maintain job logs (`docs/logs/`) and prune outdated `AGENTS.md` references.
- **Dependencies**: Phases 1–6 supply content.
- **Acceptance**
  - `sbt mdoc` succeeds; VitePress build passes; docs preview includes new guides.
  - README and CONTRIBUTING updated with new workflows.

### Phase 8 — Database, Scripts & CI Hardening
- **Tasks**
  - Merge script updates: `build-docs.sh`, `ensure-postgres.sh`, `pg-init-codegen.sh`; ensure they align with repository expectations.
  - Synchronize PG DDL and regenerated bindings; document regeneration process.
  - Update GitHub Actions workflows to include docs build, tests, website publishing as appropriate.
  - Add quick-verify script revisions if relevant, ensuring deterministic output.
- **Dependencies**: Baseline knowledge; integrate near end to avoid churn.
- **Acceptance**
  - Scripts pass shellcheck (if applicable) and manual smoke tests.
  - CI green on PR with new steps included.

### Phase 9 — Optional Enhancements & Cleanup
- **Tasks**
  - Reintroduce optional components (CLI examples, advanced metrics, front-end demo) as time allows.
  - Remove obsolete documents and tidy `docs-deploy` artifacts no longer needed.
  - Final sweep of `AGENTS.md`, leaving only active directives.
- **Dependencies**: All prior phases.
- **Acceptance**
  - Repo tidy, docs accurate, logs up to date.

Testing Matrix
--------------
- **Unit**: Constructors, chunkers, sniffers, descriptors, planners.
- **Integration**: Ingest pipeline (FS, in-memory), storage substrates, PG repos.
- **Property/Stress**: Chunking determinism, concurrent ingest with resource pools, optimizer invariants.
- **Docs**: `sbt mdoc`, `npm run docs:build`, link checker (add script or GH workflow).
- **CI**: `TESTCONTAINERS=0 ./sbt scalafmtAll test`, optional PG-enabled suites via `scripts/ensure-postgres.sh`.

Documentation & Website Playbook
--------------------------------
- Maintain VitePress as the shipping surface.
- Adopt `sbt mdoc` for code snippets; ensure dev workflow includes running mdoc before committing docs.
- Convert key Docusaurus guides into VitePress equivalents using shared snippet sources.
- Keep `docs/src` (Docusaurus assets) parked or phased out as content lands in VitePress; document rationale for any remaining React components.
- Add `docs/logs/YYYY-MM-DD.md` entries for significant planning updates (this file) and prune after 6-week window.
- Update CONTRIBUTING with new commands, doc writing expectations, and job log standards.

Streaming & Storage Technical Notes
-----------------------------------
- Favor zero/minimal copy: `FileChannel.transferTo/From` when available, pooled direct `ByteBuffer`s for general IO.
- Temp-file pool: preallocate fixed-size scratch files, guard with semaphore, release via `Scope` management; track metrics (files in use, bytes allocated).
- Resource registry (STM): per-upload records with bytes, blocks, buffer handles; leverage for quotas and fair scheduling.
- Investigate `java.nio.MappedByteBuffer` for read caching; ensure explicit unmapping strategy (sun.misc cleaner or Panama when available) and config gating.
- Future: evaluate io_uring (via JNI) only after baseline stable; treat as optional experiment.

Mime Sniffer Design Notes
-------------------------
- Maintain curated signature table (extension, offset, byte pattern, confidence score).
- Provide incremental detection while streaming: inspect first N chunks, escalate to heavier parsing only if necessary.
- Integrate fallback to Apache Tika behind feature flag for large/complex types; document latency and dependencies.
- Expose confidence score + reasons in metrics/logs to aid troubleshooting.

Risk Register
-------------
- **Scala 3 Compiler Quirks**: Type-level gymnastics could trigger Dotty assertions. Mitigation: isolate advanced match types, add targeted tests, keep inline usage minimal.
- **Docs Divergence**: Running dual doc systems (VitePress + Docusaurus) can confuse contributors. Mitigation: clearly document authoritative source (VitePress), add mdoc pipeline, retire obsolete files promptly.
- **Resource Contention**: Introducing temp-file pools/buffer pools risks deadlocks if misconfigured. Mitigation: deterministic tests, metrics, conservative defaults.
- **PG Schema Drift**: Regenerating codegen can cause large diffs; ensure strict scripts + documentation for regeneration flow.
- **CI Timeouts**: Additional tests/docs builds extend pipelines. Mitigation: cache npm deps, limit heavy suites to nightly jobs, document toggles (TESTCONTAINERS=0).

Coordination & Reporting
------------------------
- Update this log after each phase with:
  - What landed (summary + links to PRs/commits).
  - Outstanding risks/issues.
  - Next planned work.
- Weekly prune `AGENTS.md` entries that are obsolete; reference this log for authoritative plan.
- For multi-agent collaboration, assign workstream owners and list them here once known.

Immediate Next Actions
----------------------
1. Confirm baseline green; ensure docs build passes (Phase 0 acceptance).
2. Draft scaffolding PR for Phase 1 (types) with tests and docs stub.
3. Begin extracting chunker implementations from `docs-deploy`, adapt to new types, and set up selection heuristics.
4. Prepare mime sniffer design doc (if needed) referencing detection table and performance goals.
5. Sketch mdoc integration plan (file layout, sbt settings) prior to Phase 7 coding.

Command Cheat Sheet
-------------------
- Build & test: `TESTCONTAINERS=0 ./sbt scalafmtAll test`
- Compile only: `TESTCONTAINERS=0 ./sbt compile`
- Docs preview: `cd docs && npm ci && npm run docs:dev`
- Docs build (VitePress): `cd docs && npm run docs:build`
- mdoc (planned): `./sbt mdoc`
- PG scripts: `scripts/ensure-postgres.sh`, `scripts/pg-init-codegen.sh`

Open Questions (Track & Resolve)
--------------------------------
- Where should the planner/descriptor API live (`graviton-core` vs dedicated module)?
- How aggressively do we prune Docusaurus assets—retain for reference or remove entirely once VitePress coverage complete?
- Should FastCDC defaults mirror prior branch values or be recalibrated based on new benchmarks?
- Define target precision/recall thresholds for mime sniffer before implementation begins.
- Determine whether to gate io_uring/mmap experiments behind build-time flags or runtime configuration.


