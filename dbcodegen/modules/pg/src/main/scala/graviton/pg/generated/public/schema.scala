// Code generated by dbcodegen. DO NOT EDIT.
// Schema: public

package graviton.pg.generated.public
import com.augustnagro.magnum.*
import graviton.db.{*, given}
import zio.Chunk
import zio.json.ast.Json
import zio.schema.Schema
import zio.schema.validation.Validation
enum ReplicaStatus(val value: String) derives Schema {
  case ACTIVE   extends ReplicaStatus("ACTIVE")
  case DEGRADED extends ReplicaStatus("DEGRADED")
  case OFFLINE  extends ReplicaStatus("OFFLINE")
}
object ReplicaStatus                                 {
  private val byValue: Map[String, ReplicaStatus] = ReplicaStatus.values.iterator.map(v => v.value -> v).toMap
  given DbCodec[ReplicaStatus]                    = DbCodec[String].biMap(
    str => byValue.getOrElse(str, throw IllegalArgumentException("Unknown replica_status value '" + str + "'")),
    _.value,
  )
}
@Table(PostgresDbType) final case class Replicas(
  @Id @SqlName("key") key: Chunk[Byte],
  @Id @SqlName("sector_id") sectorId: String,
  @Id @SqlName("range_start") rangeStart: Long,
  @SqlName("range_end") rangeEnd: Long,
  @SqlName("healthy") healthy: Boolean,
  @SqlName("status") status: ReplicaStatus,
  @SqlName("last_verified") lastVerified: Option[java.time.OffsetDateTime],
) derives DbCodec,
      Schema
object Replicas                                      {
  object Meta {
    inline val schema: String                  = "public"
    inline val table: String                   = "replicas"
    inline val columns: List[(String, String)] = List(
      "key"          -> "key",
      "sectorId"     -> "sector_id",
      "rangeStart"   -> "range_start",
      "rangeEnd"     -> "range_end",
      "healthy"      -> "healthy",
      "status"       -> "status",
      "lastVerified" -> "last_verified",
    )
  }
  opaque type Id = (key: Chunk[Byte], sectorId: String, rangeStart: Long)
  object Id   {
    def apply(key: Chunk[Byte], sectorId: String, rangeStart: Long): Id = (key = key, sectorId = sectorId, rangeStart = rangeStart)
  }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime
    .summonInline[DbCodec[(Chunk[Byte], String, Long)]]
    .biMap(value => (key = value._1, sectorId = value._2, rangeStart = value._3), id => (id.key, id.sectorId, id.rangeStart))
  given given_Schema_Id: Schema[Id] = scala.compiletime
    .summonInline[Schema[(Chunk[Byte], String, Long)]]
    .transform(value => (key = value._1, sectorId = value._2, rangeStart = value._3), id => (id.key, id.sectorId, id.rangeStart))
  final case class Creator(
    key: Chunk[Byte],
    sectorId: String,
    rangeStart: Long,
    rangeEnd: Long,
    healthy: Option[Boolean] = None,
    status: Option[ReplicaStatus] = None,
    lastVerified: Option[java.time.OffsetDateTime] = None,
  ) derives DbCodec,
        Schema
  val repo                          = Repo[Replicas.Creator, Replicas, Replicas.Id]
}
@Table(PostgresDbType) final case class Manifests(
  @Id @SqlName("key") key: Chunk[Byte],
  @SqlName("manifest_data") manifestData: Chunk[Byte],
  @SqlName("schema_version") schemaVersion: Int,
  @SqlName("attributes") attributes: Option[Json],
  @SqlName("created_at") createdAt: java.time.OffsetDateTime,
  @SqlName("updated_at") updatedAt: java.time.OffsetDateTime,
) derives DbCodec,
      Schema
object Manifests                                     {
  object Meta {
    inline val schema: String                  = "public"
    inline val table: String                   = "manifests"
    inline val columns: List[(String, String)] = List(
      "key"           -> "key",
      "manifestData"  -> "manifest_data",
      "schemaVersion" -> "schema_version",
      "attributes"    -> "attributes",
      "createdAt"     -> "created_at",
      "updatedAt"     -> "updated_at",
    )
  }
  opaque type Id = Chunk[Byte]
  object Id   {
    def apply(key: Chunk[Byte]): Id = key
    def unwrap(id: Id): Chunk[Byte] = id
  }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime.summonInline[DbCodec[Chunk[Byte]]].biMap(value => Id(value), id => Id.unwrap(id))
  given given_Schema_Id: Schema[Id] = scala.compiletime.summonInline[Schema[Chunk[Byte]]].transform(value => Id(value), id => Id.unwrap(id))
  final case class Creator(
    key: Chunk[Byte],
    manifestData: Chunk[Byte],
    schemaVersion: Option[Int] = None,
    attributes: Option[Json] = None,
    createdAt: Option[java.time.OffsetDateTime] = None,
    updatedAt: Option[java.time.OffsetDateTime] = None,
  ) derives DbCodec,
        Schema
  val repo                          = Repo[Manifests.Creator, Manifests, Manifests.Id]
}
@Table(PostgresDbType) final case class BlobData(
  @Id @SqlName("key") key: Chunk[Byte],
  @Id @SqlName("chunk_offset") chunkOffset: NonNegLong,
  @SqlName("chunk_size") chunkSize: Int,
  @SqlName("chunk_data") chunkData: Chunk[Byte],
  @SqlName("checksum") checksum: Option[Chunk[Byte]],
  @SqlName("created_at") createdAt: java.time.OffsetDateTime,
) derives DbCodec,
      Schema
object BlobData                                      {
  object Meta {
    inline val schema: String                  = "public"
    inline val table: String                   = "blob_data"
    inline val columns: List[(String, String)] = List(
      "key"         -> "key",
      "chunkOffset" -> "chunk_offset",
      "chunkSize"   -> "chunk_size",
      "chunkData"   -> "chunk_data",
      "checksum"    -> "checksum",
      "createdAt"   -> "created_at",
    )
  }
  opaque type Id = (key: Chunk[Byte], chunkOffset: NonNegLong)
  object Id   { def apply(key: Chunk[Byte], chunkOffset: NonNegLong): Id = (key = key, chunkOffset = chunkOffset) }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime
    .summonInline[DbCodec[(Chunk[Byte], NonNegLong)]]
    .biMap(value => (key = value._1, chunkOffset = value._2), id => (id.key, id.chunkOffset))
  given given_Schema_Id: Schema[Id]   = scala.compiletime
    .summonInline[Schema[(Chunk[Byte], NonNegLong)]]
    .transform(value => (key = value._1, chunkOffset = value._2), id => (id.key, id.chunkOffset))
  final case class Creator(
    key: Chunk[Byte],
    chunkOffset: NonNegLong,
    chunkSize: Int,
    chunkData: Chunk[Byte],
    checksum: Option[Chunk[Byte]] = None,
    createdAt: Option[java.time.OffsetDateTime] = None,
  ) derives DbCodec,
        Schema
  val repo                            = Repo[BlobData.Creator, BlobData, BlobData.Id]
}
@Table(PostgresDbType) final case class StorageSectors(
  @Id @SqlName("id") id: String,
  @SqlName("region") region: String,
  @SqlName("capacity_bytes") capacityBytes: NonNegLong,
  @SqlName("available_bytes") availableBytes: NonNegLong,
  @SqlName("created_at") createdAt: java.time.OffsetDateTime,
  @SqlName("updated_at") updatedAt: java.time.OffsetDateTime,
) derives DbCodec,
      Schema
object StorageSectors                                {
  object Meta {
    inline val schema: String                  = "public"
    inline val table: String                   = "storage_sectors"
    inline val columns: List[(String, String)] = List(
      "id"             -> "id",
      "region"         -> "region",
      "capacityBytes"  -> "capacity_bytes",
      "availableBytes" -> "available_bytes",
      "createdAt"      -> "created_at",
      "updatedAt"      -> "updated_at",
    )
  }
  opaque type Id = String
  object Id   {
    def apply(id: String): Id  = id
    def unwrap(id: Id): String = id
  }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime.summonInline[DbCodec[String]].biMap(value => Id(value), id => Id.unwrap(id))
  given given_Schema_Id: Schema[Id] = scala.compiletime.summonInline[Schema[String]].transform(value => Id(value), id => Id.unwrap(id))
  final case class Creator(
    id: String,
    region: String,
    capacityBytes: NonNegLong,
    availableBytes: NonNegLong,
    createdAt: Option[java.time.OffsetDateTime] = None,
    updatedAt: Option[java.time.OffsetDateTime] = None,
  ) derives DbCodec,
        Schema
  val repo                          = Repo[StorageSectors.Creator, StorageSectors, StorageSectors.Id]
}
@Table(PostgresDbType) final case class Blobs(
  @Id @SqlName("key") key: Chunk[Byte],
  @SqlName("size") size: NonNegLong,
  @SqlName("checksum") checksum: Option[Chunk[Byte]],
  @SqlName("content_type") contentType: Option[String],
  @SqlName("attributes") attributes: Option[Json],
  @SqlName("created_at") createdAt: java.time.OffsetDateTime,
  @SqlName("updated_at") updatedAt: java.time.OffsetDateTime,
  @SqlName("version") version: NonNegLong,
) derives DbCodec,
      Schema
object Blobs                                         {
  object Meta {
    inline val schema: String                  = "public"
    inline val table: String                   = "blobs"
    inline val columns: List[(String, String)] = List(
      "key"         -> "key",
      "size"        -> "size",
      "checksum"    -> "checksum",
      "contentType" -> "content_type",
      "attributes"  -> "attributes",
      "createdAt"   -> "created_at",
      "updatedAt"   -> "updated_at",
      "version"     -> "version",
    )
  }
  opaque type Id = Chunk[Byte]
  object Id   {
    def apply(key: Chunk[Byte]): Id = key
    def unwrap(id: Id): Chunk[Byte] = id
  }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime.summonInline[DbCodec[Chunk[Byte]]].biMap(value => Id(value), id => Id.unwrap(id))
  given given_Schema_Id: Schema[Id] = scala.compiletime.summonInline[Schema[Chunk[Byte]]].transform(value => Id(value), id => Id.unwrap(id))
  final case class Creator(
    key: Chunk[Byte],
    size: NonNegLong,
    checksum: Option[Chunk[Byte]] = None,
    contentType: Option[String] = None,
    attributes: Option[Json] = None,
    createdAt: Option[java.time.OffsetDateTime] = None,
    updatedAt: Option[java.time.OffsetDateTime] = None,
    version: Option[NonNegLong] = None,
  ) derives DbCodec,
        Schema
  val repo                          = Repo[Blobs.Creator, Blobs, Blobs.Id]
}
