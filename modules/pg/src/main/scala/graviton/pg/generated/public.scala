// Code generated by dbcodegen. DO NOT EDIT.
// Schema: public

package graviton.pg.generated

import com.augustnagro.magnum.*
import graviton.db.{*, given}
import zio.Chunk
import zio.json.ast.Json
import zio.schema.{DeriveSchema, Schema}

@Table(PostgresDbType)
final case class BuildInfo(
  @Id
  @SqlName("id")
  id: Long,
  @SqlName("app_name")
  appName: String,
  @SqlName("version")
  version: String,
  @SqlName("git_sha")
  gitSha: String,
  @SqlName("scala_version")
  scalaVersion: String,
  @SqlName("zio_version")
  zioVersion: String,
  @SqlName("built_at")
  builtAt: java.time.OffsetDateTime,
  @SqlName("launched_at")
  launchedAt: java.time.OffsetDateTime,
  @SqlName("is_current")
  isCurrent: Boolean,
) derives DbCodec

object BuildInfo:
  opaque type Id <: Tuple = Tuple1[Long]
  type Tupled             = (id: Long)

  object Id:
    def fromTuple(tuple: Tupled): Id = tuple.asInstanceOf[Id]
    def toTuple(id: Id): Tupled      = id.asInstanceOf[Tupled]
    def apply(id: Long): Id          = fromTuple((id = id))

  given given_DbCodec_Id: DbCodec[Id] =
    scala.compiletime.summonInline[DbCodec[Long]].biMap(value => BuildInfo.Id.fromTuple((id = value)), id => BuildInfo.Id.toTuple(id).id)

  extension (id: Id) def id: Long = BuildInfo.Id.toTuple(id).id

  final case class Creator(
    id: Option[BuildInfo.Id] = None,
    appName: String,
    version: String,
    gitSha: String,
    scalaVersion: String,
    zioVersion: String,
    builtAt: java.time.OffsetDateTime,
    launchedAt: java.time.OffsetDateTime,
    isCurrent: Option[Boolean] = None,
  ) derives DbCodec

  val repo = Repo[BuildInfo.Creator, BuildInfo, BuildInfo.Id]

@Table(PostgresDbType)
final case class HashAlgorithm(
  @Id
  @SqlName("id")
  id: Short,
  @SqlName("name")
  name: String,
  @SqlName("is_fips")
  isFips: Boolean,
) derives DbCodec

object HashAlgorithm:
  opaque type Id <: Tuple = Tuple1[Short]
  type Tupled             = (id: Short)

  object Id:
    def fromTuple(tuple: Tupled): Id = tuple.asInstanceOf[Id]
    def toTuple(id: Id): Tupled      = id.asInstanceOf[Tupled]
    def apply(id: Short): Id         = fromTuple((id = id))

  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime
    .summonInline[DbCodec[Short]]
    .biMap(value => HashAlgorithm.Id.fromTuple((id = value)), id => HashAlgorithm.Id.toTuple(id).id)

  extension (id: Id) def id: Short = HashAlgorithm.Id.toTuple(id).id

  final case class Creator(
    id: Option[HashAlgorithm.Id] = None,
    name: String,
    isFips: Option[Boolean] = None,
  ) derives DbCodec

  val repo = Repo[HashAlgorithm.Creator, HashAlgorithm, HashAlgorithm.Id]

@Table(PostgresDbType)
final case class Store(
  @Id
  @SqlName("key")
  key: StoreKey,
  @SqlName("impl_id")
  implId: String,
  @SqlName("build_fp")
  buildFp: Chunk[Byte],
  @SqlName("dv_schema_urn")
  dvSchemaUrn: String,
  @SqlName("dv_canonical_bin")
  dvCanonicalBin: Chunk[Byte],
  @SqlName("dv_json_preview")
  dvJsonPreview: Option[Json],
  @SqlName("status")
  status: StoreStatus,
  @SqlName("version")
  version: NonNegLong,
  @SqlName("created_at")
  createdAt: java.time.OffsetDateTime,
  @SqlName("updated_at")
  updatedAt: java.time.OffsetDateTime,
  @SqlName("dv_hash")
  dvHash: Option[Chunk[Byte]],
) derives DbCodec

object Store:
  opaque type Id <: Tuple = Tuple1[StoreKey]
  type Tupled             = (key: StoreKey)

  object Id:
    def fromTuple(tuple: Tupled): Id = tuple.asInstanceOf[Id]
    def toTuple(id: Id): Tupled      = id.asInstanceOf[Tupled]
    def apply(key: StoreKey): Id     = fromTuple((key = key))

  given given_DbCodec_Id: DbCodec[Id] =
    scala.compiletime.summonInline[DbCodec[StoreKey]].biMap(value => Store.Id.fromTuple((key = value)), id => Store.Id.toTuple(id).key)

  extension (id: Id) def key: StoreKey = Store.Id.toTuple(id).key

  final case class Creator(
    key: StoreKey,
    implId: String,
    buildFp: Chunk[Byte],
    dvSchemaUrn: String,
    dvCanonicalBin: Chunk[Byte],
    dvJsonPreview: Option[Json] = None,
    status: Option[StoreStatus] = None,
    version: Option[NonNegLong] = None,
    createdAt: Option[java.time.OffsetDateTime] = None,
    updatedAt: Option[java.time.OffsetDateTime] = None,
    dvHash: Option[Chunk[Byte]] = None,
  ) derives DbCodec

  val repo = Repo[Store.Creator, Store, Store.Id]

@Table(PostgresDbType)
final case class Blob(
  @Id
  @SqlName("id")
  id: java.util.UUID,
  @SqlName("algo_id")
  algoId: Short,
  @SqlName("hash")
  hash: HashBytes,
  @SqlName("size_bytes")
  sizeBytes: PosLong,
  @SqlName("media_type_hint")
  mediaTypeHint: Option[String],
  @SqlName("created_at")
  createdAt: java.time.OffsetDateTime,
) derives DbCodec

object Blob:
  opaque type Id <: Tuple = Tuple1[java.util.UUID]
  type Tupled             = (id: java.util.UUID)

  object Id:
    def fromTuple(tuple: Tupled): Id  = tuple.asInstanceOf[Id]
    def toTuple(id: Id): Tupled       = id.asInstanceOf[Tupled]
    def apply(id: java.util.UUID): Id = fromTuple((id = id))

  given given_DbCodec_Id: DbCodec[Id] =
    scala.compiletime.summonInline[DbCodec[java.util.UUID]].biMap(value => Blob.Id.fromTuple((id = value)), id => Blob.Id.toTuple(id).id)

  extension (id: Id) def id: java.util.UUID = Blob.Id.toTuple(id).id

  final case class Creator(
    id: Option[Blob.Id] = None,
    algoId: Short,
    hash: HashBytes,
    sizeBytes: PosLong,
    mediaTypeHint: Option[String] = None,
    createdAt: Option[java.time.OffsetDateTime] = None,
  ) derives DbCodec

  val repo = Repo[Blob.Creator, Blob, Blob.Id]

@Table(PostgresDbType)
final case class Block(
  @Id
  @SqlName("algo_id")
  algoId: Short,
  @Id
  @SqlName("hash")
  hash: HashBytes,
  @SqlName("size_bytes")
  sizeBytes: PosLong,
  @SqlName("created_at")
  createdAt: java.time.OffsetDateTime,
  @SqlName("inline_bytes")
  inlineBytes: Option[SmallBytes],
) derives DbCodec

object Block:
  opaque type Id <: Tuple = (Short, HashBytes)
  type Tupled             = (
    algoId: Short,
    hash: HashBytes,
  )

  object Id:
    def fromTuple(tuple: Tupled): Id              = tuple.asInstanceOf[Id]
    def toTuple(id: Id): Tupled                   = id.asInstanceOf[Tupled]
    def apply(algoId: Short, hash: HashBytes): Id = fromTuple((algoId = algoId, hash = hash))

  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime
    .summonInline[DbCodec[(Short, HashBytes)]]
    .biMap(
      value => Block.Id.fromTuple((algoId = value._1, hash = value._2)),
      id => (Block.Id.toTuple(id).algoId, Block.Id.toTuple(id).hash),
    )

  extension (id: Id)
    def algoId: Short   = Block.Id.toTuple(id).algoId
    def hash: HashBytes = Block.Id.toTuple(id).hash

  final case class Creator(
    algoId: Short,
    hash: HashBytes,
    sizeBytes: PosLong,
    createdAt: Option[java.time.OffsetDateTime] = None,
    inlineBytes: Option[SmallBytes] = None,
  ) derives DbCodec

  val repo = Repo[Block.Creator, Block, Block.Id]

@Table(PostgresDbType)
final case class MerkleSnapshot(
  @Id
  @SqlName("id")
  id: Long,
  @SqlName("query_fingerprint")
  queryFingerprint: Chunk[Byte],
  @SqlName("algo_id")
  algoId: Short,
  @SqlName("root_hash")
  rootHash: HashBytes,
  @SqlName("at_time")
  atTime: java.time.OffsetDateTime,
  @SqlName("note")
  note: Option[String],
) derives DbCodec

object MerkleSnapshot:
  opaque type Id <: Tuple = Tuple1[Long]
  type Tupled             = (id: Long)

  object Id:
    def fromTuple(tuple: Tupled): Id = tuple.asInstanceOf[Id]
    def toTuple(id: Id): Tupled      = id.asInstanceOf[Tupled]
    def apply(id: Long): Id          = fromTuple((id = id))

  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime
    .summonInline[DbCodec[Long]]
    .biMap(value => MerkleSnapshot.Id.fromTuple((id = value)), id => MerkleSnapshot.Id.toTuple(id).id)

  extension (id: Id) def id: Long = MerkleSnapshot.Id.toTuple(id).id

  final case class Creator(
    id: Option[MerkleSnapshot.Id] = None,
    queryFingerprint: Chunk[Byte],
    algoId: Short,
    rootHash: HashBytes,
    atTime: Option[java.time.OffsetDateTime] = None,
    note: Option[String] = None,
  ) derives DbCodec

  val repo = Repo[MerkleSnapshot.Creator, MerkleSnapshot, MerkleSnapshot.Id]

@Table(PostgresDbType)
final case class ManifestEntry(
  @Id
  @SqlName("blob_id")
  blobId: java.util.UUID,
  @Id
  @SqlName("seq")
  seq: Int,
  @SqlName("block_algo_id")
  blockAlgoId: Short,
  @SqlName("block_hash")
  blockHash: HashBytes,
  @SqlName("offset_bytes")
  offsetBytes: PosLong,
  @SqlName("size_bytes")
  sizeBytes: PosLong,
  @SqlName("span")
  span: Option[DbRange[Long]],
) derives DbCodec

object ManifestEntry:
  opaque type Id <: Tuple = (java.util.UUID, Int)
  type Tupled             = (
    blobId: java.util.UUID,
    seq: Int,
  )

  object Id:
    def fromTuple(tuple: Tupled): Id                = tuple.asInstanceOf[Id]
    def toTuple(id: Id): Tupled                     = id.asInstanceOf[Tupled]
    def apply(blobId: java.util.UUID, seq: Int): Id = fromTuple((blobId = blobId, seq = seq))

  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime
    .summonInline[DbCodec[(java.util.UUID, Int)]]
    .biMap(
      value => ManifestEntry.Id.fromTuple((blobId = value._1, seq = value._2)),
      id => (ManifestEntry.Id.toTuple(id).blobId, ManifestEntry.Id.toTuple(id).seq),
    )

  extension (id: Id)
    def blobId: java.util.UUID = ManifestEntry.Id.toTuple(id).blobId
    def seq: Int               = ManifestEntry.Id.toTuple(id).seq

  final case class Creator(
    blobId: java.util.UUID,
    seq: Int,
    blockAlgoId: Short,
    blockHash: HashBytes,
    offsetBytes: PosLong,
    sizeBytes: PosLong,
    span: Option[DbRange[Long]] = None,
  ) derives DbCodec

  val repo = Repo[ManifestEntry.Creator, ManifestEntry, ManifestEntry.Id]

@Table(PostgresDbType)
final case class Replica(
  @Id
  @SqlName("id")
  id: Long,
  @SqlName("algo_id")
  algoId: Short,
  @SqlName("hash")
  hash: HashBytes,
  @SqlName("store_key")
  storeKey: StoreKey,
  @SqlName("sector")
  sector: Option[String],
  @SqlName("status")
  status: ReplicaStatus,
  @SqlName("size_bytes")
  sizeBytes: PosLong,
  @SqlName("etag")
  etag: Option[String],
  @SqlName("storage_class")
  storageClass: Option[String],
  @SqlName("first_seen_at")
  firstSeenAt: java.time.OffsetDateTime,
  @SqlName("last_verified_at")
  lastVerifiedAt: Option[java.time.OffsetDateTime],
) derives DbCodec

object Replica:
  opaque type Id <: Tuple = Tuple1[Long]
  type Tupled             = (id: Long)

  object Id:
    def fromTuple(tuple: Tupled): Id = tuple.asInstanceOf[Id]
    def toTuple(id: Id): Tupled      = id.asInstanceOf[Tupled]
    def apply(id: Long): Id          = fromTuple((id = id))

  given given_DbCodec_Id: DbCodec[Id] =
    scala.compiletime.summonInline[DbCodec[Long]].biMap(value => Replica.Id.fromTuple((id = value)), id => Replica.Id.toTuple(id).id)

  extension (id: Id) def id: Long = Replica.Id.toTuple(id).id

  final case class Creator(
    id: Option[Replica.Id] = None,
    algoId: Short,
    hash: HashBytes,
    storeKey: StoreKey,
    sector: Option[String] = None,
    status: Option[ReplicaStatus] = None,
    sizeBytes: PosLong,
    etag: Option[String] = None,
    storageClass: Option[String] = None,
    firstSeenAt: Option[java.time.OffsetDateTime] = None,
    lastVerifiedAt: Option[java.time.OffsetDateTime] = None,
  ) derives DbCodec

  val repo = Repo[Replica.Creator, Replica, Replica.Id]

@Table(PostgresDbType)
final case class VBlobManifest(
  @SqlName("id")
  id: Option[java.util.UUID],
  @SqlName("hash")
  hash: Option[HashBytes],
  @SqlName("size_bytes")
  sizeBytes: Option[PosLong],
  @SqlName("media_type_hint")
  mediaTypeHint: Option[String],
  @SqlName("created_at")
  createdAt: Option[java.time.OffsetDateTime],
  @SqlName("manifest")
  manifest: Option[Json],
) derives DbCodec

object VBlobManifest:
  type Id = Null

  val repo = ImmutableRepo[VBlobManifest, VBlobManifest.Id]

@Table(PostgresDbType)
final case class VBlockReplicaHealth(
  @SqlName("algo_id")
  algoId: Option[Short],
  @SqlName("hash")
  hash: Option[HashBytes],
  @SqlName("size_bytes")
  sizeBytes: Option[PosLong],
  @SqlName("created_at")
  createdAt: Option[java.time.OffsetDateTime],
  @SqlName("replica_count")
  replicaCount: Option[Long],
  @SqlName("active_count")
  activeCount: Option[Long],
  @SqlName("quarantined_count")
  quarantinedCount: Option[Long],
  @SqlName("deprecated_count")
  deprecatedCount: Option[Long],
  @SqlName("lost_count")
  lostCount: Option[Long],
  @SqlName("last_verified_at")
  lastVerifiedAt: Option[java.time.OffsetDateTime],
  @SqlName("has_active")
  hasActive: Option[Boolean],
  @SqlName("has_lost")
  hasLost: Option[Boolean],
) derives DbCodec

object VBlockReplicaHealth:
  type Id = Null

  val repo = ImmutableRepo[VBlockReplicaHealth, VBlockReplicaHealth.Id]

@Table(PostgresDbType)
final case class VStoreInventory(
  @SqlName("key")
  key: Option[StoreKey],
  @SqlName("impl_id")
  implId: Option[String],
  @SqlName("status")
  status: Option[StoreStatus],
  @SqlName("updated_at")
  updatedAt: Option[java.time.OffsetDateTime],
  @SqlName("total_replicas")
  totalReplicas: Option[Long],
  @SqlName("active_replicas")
  activeReplicas: Option[Long],
  @SqlName("quarantined_replicas")
  quarantinedReplicas: Option[Long],
  @SqlName("deprecated_replicas")
  deprecatedReplicas: Option[Long],
  @SqlName("lost_replicas")
  lostReplicas: Option[Long],
  @SqlName("first_replica_seen_at")
  firstReplicaSeenAt: Option[java.time.OffsetDateTime],
  @SqlName("last_replica_verified_at")
  lastReplicaVerifiedAt: Option[java.time.OffsetDateTime],
) derives DbCodec

object VStoreInventory:
  type Id = Null

  val repo = ImmutableRepo[VStoreInventory, VStoreInventory.Id]

// ZIO Schema definitions for public
object Schemas {
  given buildInfoSchema: Schema[BuildInfo]                     = DeriveSchema.gen[BuildInfo]
  given buildInfoIdSchema: Schema[BuildInfo.Id]                =
    scala.compiletime.summonInline[Schema[Long]].transform(value => BuildInfo.Id.fromTuple((id = value)), id => BuildInfo.Id.toTuple(id).id)
  given hashAlgorithmSchema: Schema[HashAlgorithm]             = DeriveSchema.gen[HashAlgorithm]
  given hashAlgorithmIdSchema: Schema[HashAlgorithm.Id]        = scala.compiletime
    .summonInline[Schema[Short]]
    .transform(value => HashAlgorithm.Id.fromTuple((id = value)), id => HashAlgorithm.Id.toTuple(id).id)
  given storeSchema: Schema[Store]                             = DeriveSchema.gen[Store]
  given storeIdSchema: Schema[Store.Id]                        =
    scala.compiletime.summonInline[Schema[StoreKey]].transform(value => Store.Id.fromTuple((key = value)), id => Store.Id.toTuple(id).key)
  given blobSchema: Schema[Blob]                               = DeriveSchema.gen[Blob]
  given blobIdSchema: Schema[Blob.Id]                          =
    scala.compiletime.summonInline[Schema[java.util.UUID]].transform(value => Blob.Id.fromTuple((id = value)), id => Blob.Id.toTuple(id).id)
  given blockSchema: Schema[Block]                             = DeriveSchema.gen[Block]
  given blockIdSchema: Schema[Block.Id]                        = scala.compiletime
    .summonInline[Schema[(Short, HashBytes)]]
    .transform(
      value => Block.Id.fromTuple((algoId = value._1, hash = value._2)),
      id => (Block.Id.toTuple(id).algoId, Block.Id.toTuple(id).hash),
    )
  given merkleSnapshotSchema: Schema[MerkleSnapshot]           = DeriveSchema.gen[MerkleSnapshot]
  given merkleSnapshotIdSchema: Schema[MerkleSnapshot.Id]      = scala.compiletime
    .summonInline[Schema[Long]]
    .transform(value => MerkleSnapshot.Id.fromTuple((id = value)), id => MerkleSnapshot.Id.toTuple(id).id)
  given manifestEntrySchema: Schema[ManifestEntry]             = DeriveSchema.gen[ManifestEntry]
  given manifestEntryIdSchema: Schema[ManifestEntry.Id]        = scala.compiletime
    .summonInline[Schema[(java.util.UUID, Int)]]
    .transform(
      value => ManifestEntry.Id.fromTuple((blobId = value._1, seq = value._2)),
      id => (ManifestEntry.Id.toTuple(id).blobId, ManifestEntry.Id.toTuple(id).seq),
    )
  given replicaSchema: Schema[Replica]                         = DeriveSchema.gen[Replica]
  given replicaIdSchema: Schema[Replica.Id]                    =
    scala.compiletime.summonInline[Schema[Long]].transform(value => Replica.Id.fromTuple((id = value)), id => Replica.Id.toTuple(id).id)
  given vBlobManifestSchema: Schema[VBlobManifest]             = DeriveSchema.gen[VBlobManifest]
  given vBlockReplicaHealthSchema: Schema[VBlockReplicaHealth] = DeriveSchema.gen[VBlockReplicaHealth]
  given vStoreInventorySchema: Schema[VStoreInventory]         = DeriveSchema.gen[VStoreInventory]
}
