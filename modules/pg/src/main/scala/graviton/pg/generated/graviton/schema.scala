// Code generated by dbcodegen. DO NOT EDIT.
// Schema: graviton

package graviton.pg.generated.graviton
import com.augustnagro.magnum._
import graviton.db.{ _, given }
import zio.Chunk
import zio.json.ast.Json
import zio.schema.{ DeriveSchema, Schema }
import zio.schema.validation.Validation
enum HashAlg(val value: String) {
  case sha256 extends HashAlg("sha256")
  case blake3 extends HashAlg("blake3")
}
object HashAlg { given Schema[HashAlg] = DeriveSchema.gen[HashAlg] }
enum PresentStatus(val value: String) {
  case present extends PresentStatus("present")
  case missing extends PresentStatus("missing")
  case corrupt extends PresentStatus("corrupt")
  case relocating extends PresentStatus("relocating")
}
object PresentStatus { given Schema[PresentStatus] = DeriveSchema.gen[PresentStatus] }
enum VerifyResult(val value: String) {
  case ok extends VerifyResult("ok")
  case missing extends VerifyResult("missing")
  case hash_mismatch extends VerifyResult("hash_mismatch")
  case decrypt_fail extends VerifyResult("decrypt_fail")
  case other extends VerifyResult("other")
}
object VerifyResult { given Schema[VerifyResult] = DeriveSchema.gen[VerifyResult] }
enum LifecycleStatus(val value: String) {
  case active extends LifecycleStatus("active")
  case draining extends LifecycleStatus("draining")
  case deprecated extends LifecycleStatus("deprecated")
  case dead extends LifecycleStatus("dead")
}
object LifecycleStatus { given Schema[LifecycleStatus] = DeriveSchema.gen[LifecycleStatus] }
enum InputKind(val value: String) {
  case blob extends InputKind("blob")
  case view extends InputKind("view")
}
object InputKind { given Schema[InputKind] = DeriveSchema.gen[InputKind] }
enum ViewStatus(val value: String) {
  case virtual extends ViewStatus("virtual")
  case materialized extends ViewStatus("materialized")
  case failed extends ViewStatus("failed")
}
object ViewStatus { given Schema[ViewStatus] = DeriveSchema.gen[ViewStatus] }
@Table(PostgresDbType) final case class VBestBlockLocation(@SqlName("alg") alg: Option[HashAlg], @SqlName("hash_bytes") hashBytes: Option[Chunk[Byte]], @SqlName("byte_length") byteLength: Option[NonNegLong], @SqlName("sector_priority") sectorPriority: Option[Int], @SqlName("sector_id") sectorId: Option[java.util.UUID], @SqlName("blob_store_id") blobStoreId: Option[java.util.UUID], @SqlName("block_location_id") blockLocationId: Option[java.util.UUID], @SqlName("status") status: Option[PresentStatus], @SqlName("locator") locator: Option[Json], @SqlName("locator_canonical") locatorCanonical: Option[String], @SqlName("stored_length") storedLength: Option[NonNegLong], @SqlName("frame_format") frameFormat: Option[Int], @SqlName("encryption") encryption: Option[Json], @SqlName("written_at") writtenAt: Option[java.time.OffsetDateTime], @SqlName("verified_at") verifiedAt: Option[java.time.OffsetDateTime]) derives DbCodec
object VBestBlockLocation {
  type Id = Null
  val repo = ImmutableRepo[VBestBlockLocation, VBestBlockLocation.Id]
}
@Table(PostgresDbType) final case class BlockVerifyEvent(@Id @SqlName("event_id") eventId: java.util.UUID, @SqlName("alg") alg: HashAlg, @SqlName("hash_bytes") hashBytes: Chunk[Byte], @SqlName("byte_length") byteLength: NonNegLong, @SqlName("block_location_id") blockLocationId: Option[java.util.UUID], @SqlName("result") result: VerifyResult, @SqlName("details") details: Json, @SqlName("created_at") createdAt: java.time.OffsetDateTime) derives DbCodec
object BlockVerifyEvent {
  opaque type Id = java.util.UUID
  object Id {
    def apply(eventId: java.util.UUID): Id = eventId
    def unwrap(id: Id): java.util.UUID = id
  }
  given given_DbCodec_Id: DbCodec[Id] =
    scala.compiletime.summonInline[DbCodec[java.util.UUID]].biMap(value => Id(value), id => Id.unwrap(id))
  final case class Creator(id: Option[BlockVerifyEvent.Id] = None, alg: HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong, blockLocationId: Option[java.util.UUID] = None, result: VerifyResult, details: Option[Json] = None, createdAt: Option[java.time.OffsetDateTime] = None) derives DbCodec
  val repo = Repo[BlockVerifyEvent.Creator, BlockVerifyEvent, BlockVerifyEvent.Id]
}
@Table(PostgresDbType) final case class BlockLocation(@Id @SqlName("block_location_id") blockLocationId: java.util.UUID, @SqlName("alg") alg: HashAlg, @SqlName("hash_bytes") hashBytes: Chunk[Byte], @SqlName("byte_length") byteLength: NonNegLong, @SqlName("sector_id") sectorId: java.util.UUID, @SqlName("locator") locator: Json, @SqlName("locator_canonical") locatorCanonical: Option[String], @SqlName("stored_length") storedLength: NonNegLong, @SqlName("frame_format") frameFormat: Int, @SqlName("encryption") encryption: Json, @SqlName("status") status: PresentStatus, @SqlName("written_at") writtenAt: java.time.OffsetDateTime, @SqlName("verified_at") verifiedAt: Option[java.time.OffsetDateTime]) derives DbCodec
object BlockLocation {
  opaque type Id = java.util.UUID
  object Id {
    def apply(blockLocationId: java.util.UUID): Id = blockLocationId
    def unwrap(id: Id): java.util.UUID = id
  }
  given given_DbCodec_Id: DbCodec[Id] =
    scala.compiletime.summonInline[DbCodec[java.util.UUID]].biMap(value => Id(value), id => Id.unwrap(id))
  final case class Creator(id: Option[BlockLocation.Id] = None, alg: HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong, sectorId: java.util.UUID, locator: Json, locatorCanonical: Option[String] = None, storedLength: NonNegLong, frameFormat: Option[Int] = None, encryption: Option[Json] = None, status: Option[PresentStatus] = None, writtenAt: Option[java.time.OffsetDateTime] = None, verifiedAt: Option[java.time.OffsetDateTime] = None) derives DbCodec
  val repo = Repo[BlockLocation.Creator, BlockLocation, BlockLocation.Id]
}
@Table(PostgresDbType) final case class ViewOp(@Id @SqlName("view_id") viewId: java.util.UUID, @Id @SqlName("ordinal") ordinal: Int, @SqlName("transform_id") transformId: java.util.UUID, @SqlName("args") args: Json) derives DbCodec
object ViewOp {
  opaque type Id = (viewId: java.util.UUID, ordinal: Int)
  object Id { def apply(viewId: java.util.UUID, ordinal: Int): Id = (viewId = viewId, ordinal = ordinal) }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime.summonInline[DbCodec[(java.util.UUID, Int)]].biMap(value => (viewId = value._1, ordinal = value._2), id => (id.viewId, id.ordinal))
  final case class Creator(viewId: java.util.UUID, ordinal: Int, transformId: java.util.UUID, args: Option[Json] = None) derives DbCodec
  val repo = Repo[ViewOp.Creator, ViewOp, ViewOp.Id]
}
@Table(PostgresDbType) final case class ViewMaterialization(@Id @SqlName("view_id") viewId: java.util.UUID, @SqlName("result_alg") resultAlg: HashAlg, @SqlName("result_hash_bytes") resultHashBytes: Chunk[Byte], @SqlName("result_byte_length") resultByteLength: NonNegLong, @SqlName("materialized_at") materializedAt: java.time.OffsetDateTime, @SqlName("cache_status") cacheStatus: LifecycleStatus) derives DbCodec
object ViewMaterialization {
  opaque type Id = java.util.UUID
  object Id {
    def apply(viewId: java.util.UUID): Id = viewId
    def unwrap(id: Id): java.util.UUID = id
  }
  given given_DbCodec_Id: DbCodec[Id] =
    scala.compiletime.summonInline[DbCodec[java.util.UUID]].biMap(value => Id(value), id => Id.unwrap(id))
  final case class Creator(viewId: java.util.UUID, resultAlg: HashAlg, resultHashBytes: Chunk[Byte], resultByteLength: NonNegLong, materializedAt: Option[java.time.OffsetDateTime] = None, cacheStatus: Option[LifecycleStatus] = None) derives DbCodec
  val repo = Repo[ViewMaterialization.Creator, ViewMaterialization, ViewMaterialization.Id]
}
@Table(PostgresDbType) final case class ViewInput(@Id @SqlName("view_id") viewId: java.util.UUID, @Id @SqlName("ordinal") ordinal: Int, @SqlName("input_kind") inputKind: InputKind, @SqlName("input_ref") inputRef: Json) derives DbCodec
object ViewInput {
  opaque type Id = (viewId: java.util.UUID, ordinal: Int)
  object Id { def apply(viewId: java.util.UUID, ordinal: Int): Id = (viewId = viewId, ordinal = ordinal) }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime.summonInline[DbCodec[(java.util.UUID, Int)]].biMap(value => (viewId = value._1, ordinal = value._2), id => (id.viewId, id.ordinal))
  final case class Creator(viewId: java.util.UUID, ordinal: Int, inputKind: InputKind, inputRef: Json) derives DbCodec
  val repo = Repo[ViewInput.Creator, ViewInput, ViewInput.Id]
}
@Table(PostgresDbType) final case class Sector(@Id @SqlName("sector_id") sectorId: java.util.UUID, @SqlName("blob_store_id") blobStoreId: java.util.UUID, @SqlName("name") name: String, @SqlName("priority") priority: Int, @SqlName("policy") policy: Json, @SqlName("status") status: LifecycleStatus, @SqlName("created_at") createdAt: java.time.OffsetDateTime) derives DbCodec
object Sector {
  opaque type Id = java.util.UUID
  object Id {
    def apply(sectorId: java.util.UUID): Id = sectorId
    def unwrap(id: Id): java.util.UUID = id
  }
  given given_DbCodec_Id: DbCodec[Id] =
    scala.compiletime.summonInline[DbCodec[java.util.UUID]].biMap(value => Id(value), id => Id.unwrap(id))
  final case class Creator(id: Option[Sector.Id] = None, blobStoreId: java.util.UUID, name: String, priority: Option[Int] = None, policy: Option[Json] = None, status: Option[LifecycleStatus] = None, createdAt: Option[java.time.OffsetDateTime] = None) derives DbCodec
  val repo = Repo[Sector.Creator, Sector, Sector.Id]
}
@Table(PostgresDbType) final case class BlobManifestPage(@Id @SqlName("alg") alg: HashAlg, @Id @SqlName("hash_bytes") hashBytes: Chunk[Byte], @Id @SqlName("byte_length") byteLength: NonNegLong, @Id @SqlName("page_no") pageNo: Int, @SqlName("entry_count") entryCount: Int, @SqlName("entries") entries: Chunk[Byte], @SqlName("created_at") createdAt: java.time.OffsetDateTime) derives DbCodec
object BlobManifestPage {
  opaque type Id = (alg: HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong, pageNo: Int)
  object Id { def apply(alg: HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong, pageNo: Int): Id = (alg = alg, hashBytes = hashBytes, byteLength = byteLength, pageNo = pageNo) }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime.summonInline[DbCodec[(HashAlg, Chunk[Byte], NonNegLong, Int)]].biMap(value => (alg = value._1, hashBytes = value._2, byteLength = value._3, pageNo = value._4), id => (id.alg, id.hashBytes, id.byteLength, id.pageNo))
  final case class Creator(alg: HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong, pageNo: Int, entryCount: Int, entries: Chunk[Byte], createdAt: Option[java.time.OffsetDateTime] = None) derives DbCodec
  val repo = Repo[BlobManifestPage.Creator, BlobManifestPage, BlobManifestPage.Id]
}
@Table(PostgresDbType) final case class BlobBlock(@Id @SqlName("alg") alg: HashAlg, @Id @SqlName("hash_bytes") hashBytes: Chunk[Byte], @Id @SqlName("byte_length") byteLength: NonNegLong, @Id @SqlName("ordinal") ordinal: Int, @SqlName("block_alg") blockAlg: HashAlg, @SqlName("block_hash_bytes") blockHashBytes: Chunk[Byte], @SqlName("block_byte_length") blockByteLength: NonNegLong, @SqlName("block_offset") blockOffset: NonNegLong, @SqlName("block_length") blockLength: NonNegLong, @SqlName("span") span: Option[DbRange[Long]]) derives DbCodec
object BlobBlock {
  opaque type Id = (alg: HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong, ordinal: Int)
  object Id { def apply(alg: HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong, ordinal: Int): Id = (alg = alg, hashBytes = hashBytes, byteLength = byteLength, ordinal = ordinal) }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime.summonInline[DbCodec[(HashAlg, Chunk[Byte], NonNegLong, Int)]].biMap(value => (alg = value._1, hashBytes = value._2, byteLength = value._3, ordinal = value._4), id => (id.alg, id.hashBytes, id.byteLength, id.ordinal))
  final case class Creator(alg: HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong, ordinal: Int, blockAlg: HashAlg, blockHashBytes: Chunk[Byte], blockByteLength: NonNegLong, blockOffset: NonNegLong, blockLength: NonNegLong, span: Option[DbRange[Long]] = None) derives DbCodec
  val repo = Repo[BlobBlock.Creator, BlobBlock, BlobBlock.Id]
}
@Table(PostgresDbType) final case class View(@Id @SqlName("view_id") viewId: java.util.UUID, @SqlName("canonical_key") canonicalKey: Chunk[Byte], @SqlName("status") status: ViewStatus, @SqlName("created_at") createdAt: java.time.OffsetDateTime) derives DbCodec
object View {
  opaque type Id = java.util.UUID
  object Id {
    def apply(viewId: java.util.UUID): Id = viewId
    def unwrap(id: Id): java.util.UUID = id
  }
  given given_DbCodec_Id: DbCodec[Id] =
    scala.compiletime.summonInline[DbCodec[java.util.UUID]].biMap(value => Id(value), id => Id.unwrap(id))
  final case class Creator(id: Option[View.Id] = None, canonicalKey: Chunk[Byte], status: Option[ViewStatus] = None, createdAt: Option[java.time.OffsetDateTime] = None) derives DbCodec
  val repo = Repo[View.Creator, View, View.Id]
}
@Table(PostgresDbType) final case class Transform(@Id @SqlName("transform_id") transformId: java.util.UUID, @SqlName("name") name: String, @SqlName("version") version: String, @SqlName("arg_schema") argSchema: Json, @SqlName("created_at") createdAt: java.time.OffsetDateTime) derives DbCodec
object Transform {
  opaque type Id = java.util.UUID
  object Id {
    def apply(transformId: java.util.UUID): Id = transformId
    def unwrap(id: Id): java.util.UUID = id
  }
  given given_DbCodec_Id: DbCodec[Id] =
    scala.compiletime.summonInline[DbCodec[java.util.UUID]].biMap(value => Id(value), id => Id.unwrap(id))
  final case class Creator(id: Option[Transform.Id] = None, name: String, version: String, argSchema: Option[Json] = None, createdAt: Option[java.time.OffsetDateTime] = None) derives DbCodec
  val repo = Repo[Transform.Creator, Transform, Transform.Id]
}
@Table(PostgresDbType) final case class Block(@Id @SqlName("alg") alg: HashAlg, @Id @SqlName("hash_bytes") hashBytes: Chunk[Byte], @Id @SqlName("byte_length") byteLength: NonNegLong, @SqlName("created_at") createdAt: java.time.OffsetDateTime, @SqlName("attrs") attrs: Json) derives DbCodec
object Block {
  opaque type Id = (alg: HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong)
  object Id { def apply(alg: HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong): Id = (alg = alg, hashBytes = hashBytes, byteLength = byteLength) }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime.summonInline[DbCodec[(HashAlg, Chunk[Byte], NonNegLong)]].biMap(value => (alg = value._1, hashBytes = value._2, byteLength = value._3), id => (id.alg, id.hashBytes, id.byteLength))
  final case class Creator(alg: HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong, createdAt: Option[java.time.OffsetDateTime] = None, attrs: Option[Json] = None) derives DbCodec
  val repo = Repo[Block.Creator, Block, Block.Id]
}
@Table(PostgresDbType) final case class BlobStore(@Id @SqlName("blob_store_id") blobStoreId: java.util.UUID, @SqlName("type_id") typeId: String, @SqlName("config") config: Json, @SqlName("status") status: LifecycleStatus, @SqlName("created_at") createdAt: java.time.OffsetDateTime, @SqlName("updated_at") updatedAt: java.time.OffsetDateTime) derives DbCodec
object BlobStore {
  opaque type Id = java.util.UUID
  object Id {
    def apply(blobStoreId: java.util.UUID): Id = blobStoreId
    def unwrap(id: Id): java.util.UUID = id
  }
  given given_DbCodec_Id: DbCodec[Id] =
    scala.compiletime.summonInline[DbCodec[java.util.UUID]].biMap(value => Id(value), id => Id.unwrap(id))
  final case class Creator(id: Option[BlobStore.Id] = None, typeId: String, config: Json, status: Option[LifecycleStatus] = None, createdAt: Option[java.time.OffsetDateTime] = None, updatedAt: Option[java.time.OffsetDateTime] = None) derives DbCodec
  val repo = Repo[BlobStore.Creator, BlobStore, BlobStore.Id]
}
@Table(PostgresDbType) final case class Blob(@Id @SqlName("alg") alg: HashAlg, @Id @SqlName("hash_bytes") hashBytes: Chunk[Byte], @Id @SqlName("byte_length") byteLength: NonNegLong, @SqlName("created_at") createdAt: java.time.OffsetDateTime, @SqlName("block_count") blockCount: Int, @SqlName("chunker") chunker: Json, @SqlName("attrs") attrs: Json) derives DbCodec
object Blob {
  opaque type Id = (alg: HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong)
  object Id { def apply(alg: HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong): Id = (alg = alg, hashBytes = hashBytes, byteLength = byteLength) }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime.summonInline[DbCodec[(HashAlg, Chunk[Byte], NonNegLong)]].biMap(value => (alg = value._1, hashBytes = value._2, byteLength = value._3), id => (id.alg, id.hashBytes, id.byteLength))
  final case class Creator(alg: HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong, createdAt: Option[java.time.OffsetDateTime] = None, blockCount: Int, chunker: Option[Json] = None, attrs: Option[Json] = None) derives DbCodec
  val repo = Repo[Blob.Creator, Blob, Blob.Id]
}
object Schemas {
  given vBestBlockLocationSchema: Schema[VBestBlockLocation] = DeriveSchema.gen[VBestBlockLocation]
  given blockVerifyEventSchema: Schema[BlockVerifyEvent] = DeriveSchema.gen[BlockVerifyEvent]
  given blockVerifyEventIdSchema: Schema[BlockVerifyEvent.Id] =
    scala.compiletime.summonInline[Schema[java.util.UUID]].transform(value => BlockVerifyEvent.Id(value), id => BlockVerifyEvent.Id.unwrap(id))
  given blockLocationSchema: Schema[BlockLocation] = DeriveSchema.gen[BlockLocation]
  given blockLocationIdSchema: Schema[BlockLocation.Id] =
    scala.compiletime.summonInline[Schema[java.util.UUID]].transform(value => BlockLocation.Id(value), id => BlockLocation.Id.unwrap(id))
  given viewOpSchema: Schema[ViewOp] = DeriveSchema.gen[ViewOp]
  given viewOpIdSchema: Schema[ViewOp.Id] = scala.compiletime.summonInline[Schema[(java.util.UUID, Int)]].transform(value => (viewId = value._1, ordinal = value._2), id => (id.viewId, id.ordinal))
  given viewMaterializationSchema: Schema[ViewMaterialization] = DeriveSchema.gen[ViewMaterialization]
  given viewMaterializationIdSchema: Schema[ViewMaterialization.Id] = scala.compiletime.summonInline[Schema[java.util.UUID]].transform(value => (viewId = value,), id => id.viewId)
  given viewInputSchema: Schema[ViewInput] = DeriveSchema.gen[ViewInput]
  given viewInputIdSchema: Schema[ViewInput.Id] = scala.compiletime.summonInline[Schema[(java.util.UUID, Int)]].transform(value => (viewId = value._1, ordinal = value._2), id => (id.viewId, id.ordinal))
  given sectorSchema: Schema[Sector] = DeriveSchema.gen[Sector]
  given sectorIdSchema: Schema[Sector.Id] = scala.compiletime.summonInline[Schema[java.util.UUID]].transform(value => (sectorId = value,), id => id.sectorId)
  given blobManifestPageSchema: Schema[BlobManifestPage] = DeriveSchema.gen[BlobManifestPage]
  given blobManifestPageIdSchema: Schema[BlobManifestPage.Id] = scala.compiletime.summonInline[Schema[(HashAlg, Chunk[Byte], NonNegLong, Int)]].transform(value => (alg = value._1, hashBytes = value._2, byteLength = value._3, pageNo = value._4), id => (id.alg, id.hashBytes, id.byteLength, id.pageNo))
  given blobBlockSchema: Schema[BlobBlock] = DeriveSchema.gen[BlobBlock]
  given blobBlockIdSchema: Schema[BlobBlock.Id] = scala.compiletime.summonInline[Schema[(HashAlg, Chunk[Byte], NonNegLong, Int)]].transform(value => (alg = value._1, hashBytes = value._2, byteLength = value._3, ordinal = value._4), id => (id.alg, id.hashBytes, id.byteLength, id.ordinal))
  given viewSchema: Schema[View] = DeriveSchema.gen[View]
  given viewIdSchema: Schema[View.Id] =
    scala.compiletime.summonInline[Schema[java.util.UUID]].transform(value => View.Id(value), id => View.Id.unwrap(id))
  given transformSchema: Schema[Transform] = DeriveSchema.gen[Transform]
  given transformIdSchema: Schema[Transform.Id] =
    scala.compiletime.summonInline[Schema[java.util.UUID]].transform(value => Transform.Id(value), id => Transform.Id.unwrap(id))
  given blockSchema: Schema[Block] = DeriveSchema.gen[Block]
  given blockIdSchema: Schema[Block.Id] = scala.compiletime.summonInline[Schema[(HashAlg, Chunk[Byte], NonNegLong)]].transform(value => (alg = value._1, hashBytes = value._2, byteLength = value._3), id => (id.alg, id.hashBytes, id.byteLength))
  given blobStoreSchema: Schema[BlobStore] = DeriveSchema.gen[BlobStore]
  given blobStoreIdSchema: Schema[BlobStore.Id] =
    scala.compiletime.summonInline[Schema[java.util.UUID]].transform(value => BlobStore.Id(value), id => BlobStore.Id.unwrap(id))
  given blobSchema: Schema[Blob] = DeriveSchema.gen[Blob]
  given blobIdSchema: Schema[Blob.Id] = scala.compiletime.summonInline[Schema[(HashAlg, Chunk[Byte], NonNegLong)]].transform(value => (alg = value._1, hashBytes = value._2, byteLength = value._3), id => (id.alg, id.hashBytes, id.byteLength))
}
