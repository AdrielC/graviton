// Code generated by dbcodegen. DO NOT EDIT.
// Schema: graviton

package graviton.pg.generated.graviton
import com.augustnagro.magnum._
import graviton.db.{ _, given }
import zio.Chunk
import zio.json.ast.Json
import zio.schema.Schema
import zio.schema.validation.Validation
enum InputKind(val value: String) derives Schema {
  case blob extends InputKind("blob")
  case view extends InputKind("view")
}
object InputKind {
  private val byValue: Map[String, InputKind] = InputKind.values.iterator.map(v => v.value -> v).toMap
  given DbCodec[InputKind] = DbCodec[String].biMap(str => byValue.getOrElse(str, throw IllegalArgumentException("Unknown input_kind value '" + str + "'")), _.value)
}
enum VerifyResult(val value: String) derives Schema {
  case ok extends VerifyResult("ok")
  case missing extends VerifyResult("missing")
  case hash_mismatch extends VerifyResult("hash_mismatch")
  case decrypt_fail extends VerifyResult("decrypt_fail")
  case other extends VerifyResult("other")
}
object VerifyResult {
  private val byValue: Map[String, VerifyResult] = VerifyResult.values.iterator.map(v => v.value -> v).toMap
  given DbCodec[VerifyResult] = DbCodec[String].biMap(str => byValue.getOrElse(str, throw IllegalArgumentException("Unknown verify_result value '" + str + "'")), _.value)
}
enum ViewStatus(val value: String) derives Schema {
  case virtual extends ViewStatus("virtual")
  case materialized extends ViewStatus("materialized")
  case failed extends ViewStatus("failed")
}
object ViewStatus {
  private val byValue: Map[String, ViewStatus] = ViewStatus.values.iterator.map(v => v.value -> v).toMap
  given DbCodec[ViewStatus] = DbCodec[String].biMap(str => byValue.getOrElse(str, throw IllegalArgumentException("Unknown view_status value '" + str + "'")), _.value)
}
@Table(PostgresDbType) final case class VBestBlockLocation(@SqlName("alg") alg: Option[graviton.pg.generated.core.HashAlg], @SqlName("hash_bytes") hashBytes: Option[Chunk[Byte]], @SqlName("byte_length") byteLength: Option[NonNegLong], @SqlName("sector_priority") sectorPriority: Option[Int], @SqlName("sector_id") sectorId: Option[java.util.UUID], @SqlName("blob_store_id") blobStoreId: Option[java.util.UUID], @SqlName("block_location_id") blockLocationId: Option[java.util.UUID], @SqlName("status") status: Option[graviton.pg.generated.core.PresentStatus], @SqlName("locator") locator: Option[Json], @SqlName("locator_canonical") locatorCanonical: Option[String], @SqlName("stored_length") storedLength: Option[NonNegLong], @SqlName("frame_format") frameFormat: Option[Int], @SqlName("encryption") encryption: Option[Json], @SqlName("written_at") writtenAt: Option[java.time.OffsetDateTime], @SqlName("verified_at") verifiedAt: Option[java.time.OffsetDateTime]) derives DbCodec, Schema
object VBestBlockLocation {
  type Id = Null
  val repo = ImmutableRepo[VBestBlockLocation, VBestBlockLocation.Id]
}
@Table(PostgresDbType) final case class BlockVerifyEvent(@Id @SqlName("event_id") eventId: java.util.UUID, @SqlName("alg") alg: graviton.pg.generated.core.HashAlg, @SqlName("hash_bytes") hashBytes: Chunk[Byte], @SqlName("byte_length") byteLength: NonNegLong, @SqlName("block_location_id") blockLocationId: Option[java.util.UUID], @SqlName("result") result: VerifyResult, @SqlName("details") details: Json, @SqlName("created_at") createdAt: java.time.OffsetDateTime) derives DbCodec, Schema
object BlockVerifyEvent {
  opaque type Id = java.util.UUID
  object Id {
    def apply(eventId: java.util.UUID): Id = eventId
    def unwrap(id: Id): java.util.UUID = id
  }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime.summonInline[DbCodec[java.util.UUID]].biMap(value => Id(value), id => Id.unwrap(id))
  given given_Schema_Id: Schema[Id] = scala.compiletime.summonInline[Schema[java.util.UUID]].transform(value => Id(value), id => Id.unwrap(id))
  final case class Creator(id: Option[BlockVerifyEvent.Id] = None, alg: graviton.pg.generated.core.HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong, blockLocationId: Option[java.util.UUID] = None, result: VerifyResult, details: Option[Json] = None, createdAt: Option[java.time.OffsetDateTime] = None) derives DbCodec, Schema
  val repo = Repo[BlockVerifyEvent.Creator, BlockVerifyEvent, BlockVerifyEvent.Id]
}
@Table(PostgresDbType) final case class BlockLocation(@Id @SqlName("block_location_id") blockLocationId: java.util.UUID, @SqlName("alg") alg: graviton.pg.generated.core.HashAlg, @SqlName("hash_bytes") hashBytes: Chunk[Byte], @SqlName("byte_length") byteLength: NonNegLong, @SqlName("sector_id") sectorId: java.util.UUID, @SqlName("locator") locator: Json, @SqlName("locator_canonical") locatorCanonical: Option[String], @SqlName("stored_length") storedLength: NonNegLong, @SqlName("frame_format") frameFormat: Int, @SqlName("encryption") encryption: Json, @SqlName("status") status: graviton.pg.generated.core.PresentStatus, @SqlName("written_at") writtenAt: java.time.OffsetDateTime, @SqlName("verified_at") verifiedAt: Option[java.time.OffsetDateTime]) derives DbCodec, Schema
object BlockLocation {
  opaque type Id = java.util.UUID
  object Id {
    def apply(blockLocationId: java.util.UUID): Id = blockLocationId
    def unwrap(id: Id): java.util.UUID = id
  }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime.summonInline[DbCodec[java.util.UUID]].biMap(value => Id(value), id => Id.unwrap(id))
  given given_Schema_Id: Schema[Id] = scala.compiletime.summonInline[Schema[java.util.UUID]].transform(value => Id(value), id => Id.unwrap(id))
  final case class Creator(id: Option[BlockLocation.Id] = None, alg: graviton.pg.generated.core.HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong, sectorId: java.util.UUID, locator: Json, locatorCanonical: Option[String] = None, storedLength: NonNegLong, frameFormat: Option[Int] = None, encryption: Option[Json] = None, status: Option[graviton.pg.generated.core.PresentStatus] = None, writtenAt: Option[java.time.OffsetDateTime] = None, verifiedAt: Option[java.time.OffsetDateTime] = None) derives DbCodec, Schema
  val repo = Repo[BlockLocation.Creator, BlockLocation, BlockLocation.Id]
}
@Table(PostgresDbType) final case class ViewOp(@Id @SqlName("view_id") viewId: java.util.UUID, @Id @SqlName("ordinal") ordinal: Int, @SqlName("transform_id") transformId: java.util.UUID, @SqlName("args") args: Json) derives DbCodec, Schema
object ViewOp {
  opaque type Id = (viewId: java.util.UUID, ordinal: Int)
  object Id { def apply(viewId: java.util.UUID, ordinal: Int): Id = (viewId = viewId, ordinal = ordinal) }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime.summonInline[DbCodec[(java.util.UUID, Int)]].biMap(value => (viewId = value._1, ordinal = value._2), id => (id.viewId, id.ordinal))
  given given_Schema_Id: Schema[Id] = scala.compiletime.summonInline[Schema[(java.util.UUID, Int)]].transform(value => (viewId = value._1, ordinal = value._2), id => (id.viewId, id.ordinal))
  final case class Creator(viewId: java.util.UUID, ordinal: Int, transformId: java.util.UUID, args: Option[Json] = None) derives DbCodec, Schema
  val repo = Repo[ViewOp.Creator, ViewOp, ViewOp.Id]
}
@Table(PostgresDbType) final case class ViewMaterialization(@Id @SqlName("view_id") viewId: java.util.UUID, @SqlName("result_alg") resultAlg: graviton.pg.generated.core.HashAlg, @SqlName("result_hash_bytes") resultHashBytes: Chunk[Byte], @SqlName("result_byte_length") resultByteLength: NonNegLong, @SqlName("materialized_at") materializedAt: java.time.OffsetDateTime, @SqlName("cache_status") cacheStatus: graviton.pg.generated.core.LifecycleStatus) derives DbCodec, Schema
object ViewMaterialization {
  opaque type Id = java.util.UUID
  object Id {
    def apply(viewId: java.util.UUID): Id = viewId
    def unwrap(id: Id): java.util.UUID = id
  }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime.summonInline[DbCodec[java.util.UUID]].biMap(value => Id(value), id => Id.unwrap(id))
  given given_Schema_Id: Schema[Id] = scala.compiletime.summonInline[Schema[java.util.UUID]].transform(value => Id(value), id => Id.unwrap(id))
  final case class Creator(viewId: java.util.UUID, resultAlg: graviton.pg.generated.core.HashAlg, resultHashBytes: Chunk[Byte], resultByteLength: NonNegLong, materializedAt: Option[java.time.OffsetDateTime] = None, cacheStatus: Option[graviton.pg.generated.core.LifecycleStatus] = None) derives DbCodec, Schema
  val repo = Repo[ViewMaterialization.Creator, ViewMaterialization, ViewMaterialization.Id]
}
@Table(PostgresDbType) final case class ViewInput(@Id @SqlName("view_id") viewId: java.util.UUID, @Id @SqlName("ordinal") ordinal: Int, @SqlName("input_kind") inputKind: InputKind, @SqlName("input_ref") inputRef: Json) derives DbCodec, Schema
object ViewInput {
  opaque type Id = (viewId: java.util.UUID, ordinal: Int)
  object Id { def apply(viewId: java.util.UUID, ordinal: Int): Id = (viewId = viewId, ordinal = ordinal) }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime.summonInline[DbCodec[(java.util.UUID, Int)]].biMap(value => (viewId = value._1, ordinal = value._2), id => (id.viewId, id.ordinal))
  given given_Schema_Id: Schema[Id] = scala.compiletime.summonInline[Schema[(java.util.UUID, Int)]].transform(value => (viewId = value._1, ordinal = value._2), id => (id.viewId, id.ordinal))
  final case class Creator(viewId: java.util.UUID, ordinal: Int, inputKind: InputKind, inputRef: Json) derives DbCodec, Schema
  val repo = Repo[ViewInput.Creator, ViewInput, ViewInput.Id]
}
@Table(PostgresDbType) final case class Sector(@Id @SqlName("sector_id") sectorId: java.util.UUID, @SqlName("blob_store_id") blobStoreId: java.util.UUID, @SqlName("name") name: String, @SqlName("priority") priority: Int, @SqlName("policy") policy: Json, @SqlName("status") status: graviton.pg.generated.core.LifecycleStatus, @SqlName("created_at") createdAt: java.time.OffsetDateTime) derives DbCodec, Schema
object Sector {
  opaque type Id = java.util.UUID
  object Id {
    def apply(sectorId: java.util.UUID): Id = sectorId
    def unwrap(id: Id): java.util.UUID = id
  }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime.summonInline[DbCodec[java.util.UUID]].biMap(value => Id(value), id => Id.unwrap(id))
  given given_Schema_Id: Schema[Id] = scala.compiletime.summonInline[Schema[java.util.UUID]].transform(value => Id(value), id => Id.unwrap(id))
  final case class Creator(id: Option[Sector.Id] = None, blobStoreId: java.util.UUID, name: String, priority: Option[Int] = None, policy: Option[Json] = None, status: Option[graviton.pg.generated.core.LifecycleStatus] = None, createdAt: Option[java.time.OffsetDateTime] = None) derives DbCodec, Schema
  val repo = Repo[Sector.Creator, Sector, Sector.Id]
}
@Table(PostgresDbType) final case class BlobManifestPage(@Id @SqlName("alg") alg: graviton.pg.generated.core.HashAlg, @Id @SqlName("hash_bytes") hashBytes: Chunk[Byte], @Id @SqlName("byte_length") byteLength: NonNegLong, @Id @SqlName("page_no") pageNo: Int, @SqlName("entry_count") entryCount: Int, @SqlName("entries") entries: Chunk[Byte], @SqlName("created_at") createdAt: java.time.OffsetDateTime) derives DbCodec, Schema
object BlobManifestPage {
  opaque type Id = (alg: graviton.pg.generated.core.HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong, pageNo: Int)
  object Id { def apply(alg: graviton.pg.generated.core.HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong, pageNo: Int): Id = (alg = alg, hashBytes = hashBytes, byteLength = byteLength, pageNo = pageNo) }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime.summonInline[DbCodec[(graviton.pg.generated.core.HashAlg, Chunk[Byte], NonNegLong, Int)]].biMap(value => (alg = value._1, hashBytes = value._2, byteLength = value._3, pageNo = value._4), id => (id.alg, id.hashBytes, id.byteLength, id.pageNo))
  given given_Schema_Id: Schema[Id] = scala.compiletime.summonInline[Schema[(graviton.pg.generated.core.HashAlg, Chunk[Byte], NonNegLong, Int)]].transform(value => (alg = value._1, hashBytes = value._2, byteLength = value._3, pageNo = value._4), id => (id.alg, id.hashBytes, id.byteLength, id.pageNo))
  final case class Creator(alg: graviton.pg.generated.core.HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong, pageNo: Int, entryCount: Int, entries: Chunk[Byte], createdAt: Option[java.time.OffsetDateTime] = None) derives DbCodec, Schema
  val repo = Repo[BlobManifestPage.Creator, BlobManifestPage, BlobManifestPage.Id]
}
@Table(PostgresDbType) final case class BlobBlock(@Id @SqlName("alg") alg: graviton.pg.generated.core.HashAlg, @Id @SqlName("hash_bytes") hashBytes: Chunk[Byte], @Id @SqlName("byte_length") byteLength: NonNegLong, @Id @SqlName("ordinal") ordinal: Int, @SqlName("block_alg") blockAlg: graviton.pg.generated.core.HashAlg, @SqlName("block_hash_bytes") blockHashBytes: Chunk[Byte], @SqlName("block_byte_length") blockByteLength: NonNegLong, @SqlName("block_offset") blockOffset: NonNegLong, @SqlName("block_length") blockLength: NonNegLong, @SqlName("span") span: Option[DbRange[Long]]) derives DbCodec, Schema
object BlobBlock {
  opaque type Id = (alg: graviton.pg.generated.core.HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong, ordinal: Int)
  object Id { def apply(alg: graviton.pg.generated.core.HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong, ordinal: Int): Id = (alg = alg, hashBytes = hashBytes, byteLength = byteLength, ordinal = ordinal) }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime.summonInline[DbCodec[(graviton.pg.generated.core.HashAlg, Chunk[Byte], NonNegLong, Int)]].biMap(value => (alg = value._1, hashBytes = value._2, byteLength = value._3, ordinal = value._4), id => (id.alg, id.hashBytes, id.byteLength, id.ordinal))
  given given_Schema_Id: Schema[Id] = scala.compiletime.summonInline[Schema[(graviton.pg.generated.core.HashAlg, Chunk[Byte], NonNegLong, Int)]].transform(value => (alg = value._1, hashBytes = value._2, byteLength = value._3, ordinal = value._4), id => (id.alg, id.hashBytes, id.byteLength, id.ordinal))
  final case class Creator(alg: graviton.pg.generated.core.HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong, ordinal: Int, blockAlg: graviton.pg.generated.core.HashAlg, blockHashBytes: Chunk[Byte], blockByteLength: NonNegLong, blockOffset: NonNegLong, blockLength: NonNegLong, span: Option[DbRange[Long]] = None) derives DbCodec, Schema
  val repo = Repo[BlobBlock.Creator, BlobBlock, BlobBlock.Id]
}
@Table(PostgresDbType) final case class View(@Id @SqlName("view_id") viewId: java.util.UUID, @SqlName("canonical_key") canonicalKey: Chunk[Byte], @SqlName("status") status: ViewStatus, @SqlName("created_at") createdAt: java.time.OffsetDateTime) derives DbCodec, Schema
object View {
  opaque type Id = java.util.UUID
  object Id {
    def apply(viewId: java.util.UUID): Id = viewId
    def unwrap(id: Id): java.util.UUID = id
  }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime.summonInline[DbCodec[java.util.UUID]].biMap(value => Id(value), id => Id.unwrap(id))
  given given_Schema_Id: Schema[Id] = scala.compiletime.summonInline[Schema[java.util.UUID]].transform(value => Id(value), id => Id.unwrap(id))
  final case class Creator(id: Option[View.Id] = None, canonicalKey: Chunk[Byte], status: Option[ViewStatus] = None, createdAt: Option[java.time.OffsetDateTime] = None) derives DbCodec, Schema
  val repo = Repo[View.Creator, View, View.Id]
}
@Table(PostgresDbType) final case class Transform(@Id @SqlName("transform_id") transformId: java.util.UUID, @SqlName("name") name: String, @SqlName("version") version: String, @SqlName("arg_schema") argSchema: Json, @SqlName("created_at") createdAt: java.time.OffsetDateTime) derives DbCodec, Schema
object Transform {
  opaque type Id = java.util.UUID
  object Id {
    def apply(transformId: java.util.UUID): Id = transformId
    def unwrap(id: Id): java.util.UUID = id
  }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime.summonInline[DbCodec[java.util.UUID]].biMap(value => Id(value), id => Id.unwrap(id))
  given given_Schema_Id: Schema[Id] = scala.compiletime.summonInline[Schema[java.util.UUID]].transform(value => Id(value), id => Id.unwrap(id))
  final case class Creator(id: Option[Transform.Id] = None, name: String, version: String, argSchema: Option[Json] = None, createdAt: Option[java.time.OffsetDateTime] = None) derives DbCodec, Schema
  val repo = Repo[Transform.Creator, Transform, Transform.Id]
}
@Table(PostgresDbType) final case class Block(@Id @SqlName("alg") alg: graviton.pg.generated.core.HashAlg, @Id @SqlName("hash_bytes") hashBytes: Chunk[Byte], @Id @SqlName("byte_length") byteLength: NonNegLong, @SqlName("created_at") createdAt: java.time.OffsetDateTime, @SqlName("attrs") attrs: Json) derives DbCodec, Schema
object Block {
  opaque type Id = (alg: graviton.pg.generated.core.HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong)
  object Id { def apply(alg: graviton.pg.generated.core.HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong): Id = (alg = alg, hashBytes = hashBytes, byteLength = byteLength) }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime.summonInline[DbCodec[(graviton.pg.generated.core.HashAlg, Chunk[Byte], NonNegLong)]].biMap(value => (alg = value._1, hashBytes = value._2, byteLength = value._3), id => (id.alg, id.hashBytes, id.byteLength))
  given given_Schema_Id: Schema[Id] = scala.compiletime.summonInline[Schema[(graviton.pg.generated.core.HashAlg, Chunk[Byte], NonNegLong)]].transform(value => (alg = value._1, hashBytes = value._2, byteLength = value._3), id => (id.alg, id.hashBytes, id.byteLength))
  final case class Creator(alg: graviton.pg.generated.core.HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong, createdAt: Option[java.time.OffsetDateTime] = None, attrs: Option[Json] = None) derives DbCodec, Schema
  val repo = Repo[Block.Creator, Block, Block.Id]
}
@Table(PostgresDbType) final case class BlobStore(@Id @SqlName("blob_store_id") blobStoreId: java.util.UUID, @SqlName("type_id") typeId: String, @SqlName("config") config: Json, @SqlName("status") status: graviton.pg.generated.core.LifecycleStatus, @SqlName("created_at") createdAt: java.time.OffsetDateTime, @SqlName("updated_at") updatedAt: java.time.OffsetDateTime) derives DbCodec, Schema
object BlobStore {
  opaque type Id = java.util.UUID
  object Id {
    def apply(blobStoreId: java.util.UUID): Id = blobStoreId
    def unwrap(id: Id): java.util.UUID = id
  }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime.summonInline[DbCodec[java.util.UUID]].biMap(value => Id(value), id => Id.unwrap(id))
  given given_Schema_Id: Schema[Id] = scala.compiletime.summonInline[Schema[java.util.UUID]].transform(value => Id(value), id => Id.unwrap(id))
  final case class Creator(id: Option[BlobStore.Id] = None, typeId: String, config: Json, status: Option[graviton.pg.generated.core.LifecycleStatus] = None, createdAt: Option[java.time.OffsetDateTime] = None, updatedAt: Option[java.time.OffsetDateTime] = None) derives DbCodec, Schema
  val repo = Repo[BlobStore.Creator, BlobStore, BlobStore.Id]
}
@Table(PostgresDbType) final case class Blob(@Id @SqlName("alg") alg: graviton.pg.generated.core.HashAlg, @Id @SqlName("hash_bytes") hashBytes: Chunk[Byte], @Id @SqlName("byte_length") byteLength: NonNegLong, @SqlName("created_at") createdAt: java.time.OffsetDateTime, @SqlName("block_count") blockCount: Int, @SqlName("chunker") chunker: Json, @SqlName("attrs") attrs: Json) derives DbCodec, Schema
object Blob {
  opaque type Id = (alg: graviton.pg.generated.core.HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong)
  object Id { def apply(alg: graviton.pg.generated.core.HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong): Id = (alg = alg, hashBytes = hashBytes, byteLength = byteLength) }
  given given_DbCodec_Id: DbCodec[Id] = scala.compiletime.summonInline[DbCodec[(graviton.pg.generated.core.HashAlg, Chunk[Byte], NonNegLong)]].biMap(value => (alg = value._1, hashBytes = value._2, byteLength = value._3), id => (id.alg, id.hashBytes, id.byteLength))
  given given_Schema_Id: Schema[Id] = scala.compiletime.summonInline[Schema[(graviton.pg.generated.core.HashAlg, Chunk[Byte], NonNegLong)]].transform(value => (alg = value._1, hashBytes = value._2, byteLength = value._3), id => (id.alg, id.hashBytes, id.byteLength))
  final case class Creator(alg: graviton.pg.generated.core.HashAlg, hashBytes: Chunk[Byte], byteLength: NonNegLong, createdAt: Option[java.time.OffsetDateTime] = None, blockCount: Int, chunker: Option[Json] = None, attrs: Option[Json] = None) derives DbCodec, Schema
  val repo = Repo[Blob.Creator, Blob, Blob.Id]
}
