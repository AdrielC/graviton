package volga
package free

import volga.ApplyCat
import volga.free.FreeCat

/**
 * Lightweight adapter exposing a free arrow structure on top of [[volga.free.FreeCat]].
 *
 * The underlying representation leverages the existing free symmetric monoidal
 * category with Scala lifting support. This module merely specialises the set of
 * structural nodes that are kept available and provides a small compilation helper
 * for interpreting programs into any concrete {@link volga.ApplyCat} instance.
 */
object FreeArrow:

    /** Structural nodes required to model arrow combinators. */
    type ArrowOps[U[_], Prim[_, _]] = [A, B] =>> FreeCat.Scalian[U, A, B] | Prim[A, B]

    /** Morphisms of the free arrow generated by the primitive algebra [[Prim]]. */
    type Hom[U[_], Prim[_, _], A, B] = FreeCat[U, ArrowOps[U, Prim], A, B]

    /** Primitive interpreter capable of turning primitive leaves into concrete morphisms. */
    trait PrimitiveAlgebra[H[_, _], Prim[_, _]]:
        def interpret[A, B](prim: Prim[A, B]): H[A, B]

    /**
     * Convenience constructor for embedding primitive arrows.
     */
    def embed[U[_], Prim[_, _], A, B](prim: Prim[A, B])(using FreeCat.oo[U, A], FreeCat.oo[U, B]): Hom[U, Prim, A, B] =
        FreeCat.Embed(prim)

    /**
     * Compile a free arrow into any concrete {@link volga.ApplyCat}. All structural
     * nodes are handled using the operations available on the target category, while
     * primitive leaves are delegated to the supplied algebra.
     */
    def compile[H[_, _], U[_], Prim[_, _], A, B](
        arrow: Hom[U, Prim, A, B]
    )(algebra: PrimitiveAlgebra[H, Prim])(using apply: ApplyCat[H, U]): H[A, B] =

        def loop[X, Y](node: Hom[U, Prim, X, Y]): H[X, Y] =
            node match
                case ident: FreeCat.Ident[U, ArrowOps[U, Prim], t] =>
                    apply.identity(using ident.a)

                case seq: FreeCat.Sequential[U, ArrowOps[U, Prim], a, b, c] =>
                    val left  = loop(seq.f)
                    val right = loop(seq.g)
                    apply.compose(right, left)(using seq.c, seq.a, seq.b)

                case par: FreeCat.Parallel[U, ArrowOps[U, Prim], a, b, c, d] =>
                    val left  = loop(par.f)
                    val right = loop(par.g)
                    apply.tensor(left, right)(using par.a, par.b, par.c, par.d)

                case embed: FreeCat.Embed[U, ArrowOps[U, Prim], x, y] =>
                    embed.f match
                        case sl: FreeCat.SpawnLeft[U, t] =>
                            apply.leftUnit[t](using sl.a).from

                        case sr: FreeCat.SpawnRight[U, t] =>
                            apply.rightUnit[t](using sr.a).from

                        case dl: FreeCat.DropLeft[U, t] =>
                            apply.leftUnit[t](using dl.a).to

                        case dr: FreeCat.DropRight[U, t] =>
                            apply.rightUnit[t](using dr.a).to

                        case al: FreeCat.AssocLeft[U, a1, b1, c1] =>
                            apply.associate[a1, b1, c1](using al.a, al.b, al.c).to

                        case ar: FreeCat.AssocRight[U, a1, b1, c1] =>
                            apply.associate[a1, b1, c1](using ar.a, ar.b, ar.c).from

                        case br: FreeCat.Braiding[U, a1, b1] =>
                            apply.braiding[a1, b1](using br.a, br.b)

                        case lift: FreeCat.Lift[U, a1, b1] =>
                            apply.lift(lift.f)(using lift.a, lift.b)

                        case su: FreeCat.ScalaUnit[U] =>
                            apply.scalaUnit

                        case zip: FreeCat.Zip[U, a1, b1] =>
                            apply.zip[a1, b1](using zip.a, zip.b)

                        case prim: Prim[x, y] =>
                            algebra.interpret(prim)

        loop(arrow)

end FreeArrow
